org.spongycastle.crypto.tls.DTLSServerProtocol extends org.spongycastle.crypto.tls.DTLSProtocol
protected boolean verifyRequests
    public void <init>(java.security.SecureRandom)
    {
        org.spongycastle.crypto.tls.DTLSServerProtocol r0;
        java.security.SecureRandom $r1;

        r0 := @this: org.spongycastle.crypto.tls.DTLSServerProtocol;

        $r1 := @parameter0: java.security.SecureRandom;

        specialinvoke r0.<org.spongycastle.crypto.tls.DTLSProtocol: void <init>(java.security.SecureRandom)>($r1);

        r0.<org.spongycastle.crypto.tls.DTLSServerProtocol: boolean verifyRequests> = 1;

        return;
    }
    public org.spongycastle.crypto.tls.DTLSTransport accept(org.spongycastle.crypto.tls.TlsServer, org.spongycastle.crypto.tls.DatagramTransport) throws java.io.IOException
    {
        org.spongycastle.crypto.tls.DTLSServerProtocol r0;
        org.spongycastle.crypto.tls.TlsServer $r1;
        org.spongycastle.crypto.tls.DatagramTransport $r2;
        org.spongycastle.crypto.tls.TlsFatalAlert r3;
        org.spongycastle.crypto.tls.DTLSRecordLayer r4;
        org.spongycastle.crypto.tls.SecurityParameters r5;
        org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState r6;
        java.lang.IllegalArgumentException $r7;
        org.spongycastle.crypto.tls.TlsServerContextImpl $r8;
        java.security.SecureRandom $r9;
        boolean $z0;
        org.spongycastle.crypto.prng.RandomGenerator $r10;
        byte[] $r11;
        org.spongycastle.crypto.tls.DTLSTransport $r12;
        short $s0;
        java.io.IOException r13;
        java.lang.RuntimeException r14;

        r0 := @this: org.spongycastle.crypto.tls.DTLSServerProtocol;

        $r1 := @parameter0: org.spongycastle.crypto.tls.TlsServer;

        $r2 := @parameter1: org.spongycastle.crypto.tls.DatagramTransport;

        if $r1 != null goto label1;

        $r7 = new java.lang.IllegalArgumentException;

        specialinvoke $r7.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>("\'server\' cannot be null");

        throw $r7;

     label1:
        if $r2 != null goto label2;

        $r7 = new java.lang.IllegalArgumentException;

        specialinvoke $r7.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>("\'transport\' cannot be null");

        throw $r7;

     label2:
        r5 = new org.spongycastle.crypto.tls.SecurityParameters;

        specialinvoke r5.<org.spongycastle.crypto.tls.SecurityParameters: void <init>()>();

        r5.<org.spongycastle.crypto.tls.SecurityParameters: int entity> = 0;

        r6 = new org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState;

        specialinvoke r6.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: void <init>()>();

        r6.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsServer server> = $r1;

        $r8 = new org.spongycastle.crypto.tls.TlsServerContextImpl;

        $r9 = r0.<org.spongycastle.crypto.tls.DTLSServerProtocol: java.security.SecureRandom secureRandom>;

        specialinvoke $r8.<org.spongycastle.crypto.tls.TlsServerContextImpl: void <init>(java.security.SecureRandom,org.spongycastle.crypto.tls.SecurityParameters)>($r9, r5);

        r6.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsServerContextImpl serverContext> = $r8;

        $z0 = interfaceinvoke $r1.<org.spongycastle.crypto.tls.TlsServer: boolean shouldUseGMTUnixTime()>();

        $r8 = r6.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsServerContextImpl serverContext>;

        $r10 = virtualinvoke $r8.<org.spongycastle.crypto.tls.TlsServerContextImpl: org.spongycastle.crypto.prng.RandomGenerator getNonceRandomGenerator()>();

        $r11 = staticinvoke <org.spongycastle.crypto.tls.TlsProtocol: byte[] createRandomBlock(boolean,org.spongycastle.crypto.prng.RandomGenerator)>($z0, $r10);

        r5.<org.spongycastle.crypto.tls.SecurityParameters: byte[] serverRandom> = $r11;

        $r8 = r6.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsServerContextImpl serverContext>;

        interfaceinvoke $r1.<org.spongycastle.crypto.tls.TlsServer: void init(org.spongycastle.crypto.tls.TlsServerContext)>($r8);

        r4 = new org.spongycastle.crypto.tls.DTLSRecordLayer;

        $r8 = r6.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsServerContextImpl serverContext>;

        specialinvoke r4.<org.spongycastle.crypto.tls.DTLSRecordLayer: void <init>(org.spongycastle.crypto.tls.DatagramTransport,org.spongycastle.crypto.tls.TlsContext,org.spongycastle.crypto.tls.TlsPeer,short)>($r2, $r8, $r1, 22);

     label3:
        $r12 = virtualinvoke r0.<org.spongycastle.crypto.tls.DTLSServerProtocol: org.spongycastle.crypto.tls.DTLSTransport serverHandshake(org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState,org.spongycastle.crypto.tls.DTLSRecordLayer)>(r6, r4);

     label4:
        return $r12;

     label5:
        r3 := @caughtexception;

        $s0 = virtualinvoke r3.<org.spongycastle.crypto.tls.TlsFatalAlert: short getAlertDescription()>();

        virtualinvoke r4.<org.spongycastle.crypto.tls.DTLSRecordLayer: void fail(short)>($s0);

        throw r3;

     label6:
        r13 := @caughtexception;

        virtualinvoke r4.<org.spongycastle.crypto.tls.DTLSRecordLayer: void fail(short)>(80);

        throw r13;

     label7:
        r14 := @caughtexception;

        virtualinvoke r4.<org.spongycastle.crypto.tls.DTLSRecordLayer: void fail(short)>(80);

        r3 = new org.spongycastle.crypto.tls.TlsFatalAlert;

        specialinvoke r3.<org.spongycastle.crypto.tls.TlsFatalAlert: void <init>(short,java.lang.Throwable)>(80, r14);

        throw r3;

        catch org.spongycastle.crypto.tls.TlsFatalAlert from label3 to label4 with label5;
        catch java.io.IOException from label3 to label4 with label6;
        catch java.lang.RuntimeException from label3 to label4 with label7;
    }
    protected boolean expectCertificateVerifyMessage(org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState)
    {
        org.spongycastle.crypto.tls.DTLSServerProtocol r0;
        org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState $r1;
        boolean $z0;
        short $s0;

        r0 := @this: org.spongycastle.crypto.tls.DTLSServerProtocol;

        $r1 := @parameter0: org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState;

        $s0 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: short clientCertificateType>;

        if $s0 < 0 goto label1;

        $s0 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: short clientCertificateType>;

        $z0 = staticinvoke <org.spongycastle.crypto.tls.TlsUtils: boolean hasSigningCapability(short)>($s0);

        if $z0 == 0 goto label1;

        return 1;

     label1:
        return 0;
    }
    protected byte[] generateCertificateRequest(org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState, org.spongycastle.crypto.tls.CertificateRequest) throws java.io.IOException
    {
        org.spongycastle.crypto.tls.DTLSServerProtocol r0;
        org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState $r1;
        org.spongycastle.crypto.tls.CertificateRequest $r2;
        java.io.ByteArrayOutputStream r3;
        byte[] $r4;

        r0 := @this: org.spongycastle.crypto.tls.DTLSServerProtocol;

        $r1 := @parameter0: org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState;

        $r2 := @parameter1: org.spongycastle.crypto.tls.CertificateRequest;

        r3 = new java.io.ByteArrayOutputStream;

        specialinvoke r3.<java.io.ByteArrayOutputStream: void <init>()>();

        virtualinvoke $r2.<org.spongycastle.crypto.tls.CertificateRequest: void encode(java.io.OutputStream)>(r3);

        $r4 = virtualinvoke r3.<java.io.ByteArrayOutputStream: byte[] toByteArray()>();

        return $r4;
    }
    protected byte[] generateCertificateStatus(org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState, org.spongycastle.crypto.tls.CertificateStatus) throws java.io.IOException
    {
        org.spongycastle.crypto.tls.DTLSServerProtocol r0;
        org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState $r1;
        org.spongycastle.crypto.tls.CertificateStatus $r2;
        java.io.ByteArrayOutputStream r3;
        byte[] $r4;

        r0 := @this: org.spongycastle.crypto.tls.DTLSServerProtocol;

        $r1 := @parameter0: org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState;

        $r2 := @parameter1: org.spongycastle.crypto.tls.CertificateStatus;

        r3 = new java.io.ByteArrayOutputStream;

        specialinvoke r3.<java.io.ByteArrayOutputStream: void <init>()>();

        virtualinvoke $r2.<org.spongycastle.crypto.tls.CertificateStatus: void encode(java.io.OutputStream)>(r3);

        $r4 = virtualinvoke r3.<java.io.ByteArrayOutputStream: byte[] toByteArray()>();

        return $r4;
    }
    protected byte[] generateNewSessionTicket(org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState, org.spongycastle.crypto.tls.NewSessionTicket) throws java.io.IOException
    {
        org.spongycastle.crypto.tls.DTLSServerProtocol r0;
        org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState $r1;
        org.spongycastle.crypto.tls.NewSessionTicket $r2;
        java.io.ByteArrayOutputStream r3;
        byte[] $r4;

        r0 := @this: org.spongycastle.crypto.tls.DTLSServerProtocol;

        $r1 := @parameter0: org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState;

        $r2 := @parameter1: org.spongycastle.crypto.tls.NewSessionTicket;

        r3 = new java.io.ByteArrayOutputStream;

        specialinvoke r3.<java.io.ByteArrayOutputStream: void <init>()>();

        virtualinvoke $r2.<org.spongycastle.crypto.tls.NewSessionTicket: void encode(java.io.OutputStream)>(r3);

        $r4 = virtualinvoke r3.<java.io.ByteArrayOutputStream: byte[] toByteArray()>();

        return $r4;
    }
    protected byte[] generateServerHello(org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState) throws java.io.IOException
    {
        org.spongycastle.crypto.tls.DTLSServerProtocol r0;
        org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState $r1;
        java.io.ByteArrayOutputStream r2;
        boolean $z0, $z1;
        org.spongycastle.crypto.tls.TlsServerContextImpl $r3;
        org.spongycastle.crypto.tls.SecurityParameters $r4;
        org.spongycastle.crypto.tls.TlsServer $r5;
        org.spongycastle.crypto.tls.ProtocolVersion $r6, $r7;
        org.spongycastle.crypto.tls.TlsFatalAlert $r8;
        byte[] $r9;
        int $i0;
        int[] $r10;
        short $s1;
        short[] $r11;
        java.util.Hashtable $r12, $r14;
        java.lang.Integer $r13;

        r0 := @this: org.spongycastle.crypto.tls.DTLSServerProtocol;

        $r1 := @parameter0: org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState;

        $z0 = 1;

        $r3 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsServerContextImpl serverContext>;

        $r4 = virtualinvoke $r3.<org.spongycastle.crypto.tls.TlsServerContextImpl: org.spongycastle.crypto.tls.SecurityParameters getSecurityParameters()>();

        r2 = new java.io.ByteArrayOutputStream;

        specialinvoke r2.<java.io.ByteArrayOutputStream: void <init>()>();

        $r5 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsServer server>;

        $r6 = interfaceinvoke $r5.<org.spongycastle.crypto.tls.TlsServer: org.spongycastle.crypto.tls.ProtocolVersion getServerVersion()>();

        $r3 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsServerContextImpl serverContext>;

        $r7 = virtualinvoke $r3.<org.spongycastle.crypto.tls.TlsServerContextImpl: org.spongycastle.crypto.tls.ProtocolVersion getClientVersion()>();

        $z1 = virtualinvoke $r6.<org.spongycastle.crypto.tls.ProtocolVersion: boolean isEqualOrEarlierVersionOf(org.spongycastle.crypto.tls.ProtocolVersion)>($r7);

        if $z1 != 0 goto label01;

        $r8 = new org.spongycastle.crypto.tls.TlsFatalAlert;

        specialinvoke $r8.<org.spongycastle.crypto.tls.TlsFatalAlert: void <init>(short)>(80);

        throw $r8;

     label01:
        $r3 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsServerContextImpl serverContext>;

        virtualinvoke $r3.<org.spongycastle.crypto.tls.TlsServerContextImpl: void setServerVersion(org.spongycastle.crypto.tls.ProtocolVersion)>($r6);

        $r3 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsServerContextImpl serverContext>;

        $r6 = virtualinvoke $r3.<org.spongycastle.crypto.tls.TlsServerContextImpl: org.spongycastle.crypto.tls.ProtocolVersion getServerVersion()>();

        staticinvoke <org.spongycastle.crypto.tls.TlsUtils: void writeVersion(org.spongycastle.crypto.tls.ProtocolVersion,java.io.OutputStream)>($r6, r2);

        $r9 = virtualinvoke $r4.<org.spongycastle.crypto.tls.SecurityParameters: byte[] getServerRandom()>();

        virtualinvoke r2.<java.io.ByteArrayOutputStream: void write(byte[])>($r9);

        $r9 = <org.spongycastle.crypto.tls.TlsUtils: byte[] EMPTY_BYTES>;

        staticinvoke <org.spongycastle.crypto.tls.TlsUtils: void writeOpaque8(byte[],java.io.OutputStream)>($r9, r2);

        $r5 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsServer server>;

        $i0 = interfaceinvoke $r5.<org.spongycastle.crypto.tls.TlsServer: int getSelectedCipherSuite()>();

        $r10 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: int[] offeredCipherSuites>;

        $z1 = staticinvoke <org.spongycastle.util.Arrays: boolean contains(int[],int)>($r10, $i0);

        if $z1 == 0 goto label02;

        if $i0 == 0 goto label02;

        $z1 = staticinvoke <org.spongycastle.crypto.tls.CipherSuite: boolean isSCSV(int)>($i0);

        if $z1 != 0 goto label02;

        $r3 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsServerContextImpl serverContext>;

        $r6 = virtualinvoke $r3.<org.spongycastle.crypto.tls.TlsServerContextImpl: org.spongycastle.crypto.tls.ProtocolVersion getServerVersion()>();

        $z1 = staticinvoke <org.spongycastle.crypto.tls.TlsUtils: boolean isValidCipherSuiteForVersion(int,org.spongycastle.crypto.tls.ProtocolVersion)>($i0, $r6);

        if $z1 != 0 goto label03;

     label02:
        $r8 = new org.spongycastle.crypto.tls.TlsFatalAlert;

        specialinvoke $r8.<org.spongycastle.crypto.tls.TlsFatalAlert: void <init>(short)>(80);

        throw $r8;

     label03:
        staticinvoke <org.spongycastle.crypto.tls.DTLSServerProtocol: void validateSelectedCipherSuite(int,short)>($i0, 80);

        $r4.<org.spongycastle.crypto.tls.SecurityParameters: int cipherSuite> = $i0;

        $r5 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsServer server>;

        $s1 = interfaceinvoke $r5.<org.spongycastle.crypto.tls.TlsServer: short getSelectedCompressionMethod()>();

        $r11 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: short[] offeredCompressionMethods>;

        $z1 = staticinvoke <org.spongycastle.util.Arrays: boolean contains(short[],short)>($r11, $s1);

        if $z1 != 0 goto label04;

        $r8 = new org.spongycastle.crypto.tls.TlsFatalAlert;

        specialinvoke $r8.<org.spongycastle.crypto.tls.TlsFatalAlert: void <init>(short)>(80);

        throw $r8;

     label04:
        $r4.<org.spongycastle.crypto.tls.SecurityParameters: short compressionAlgorithm> = $s1;

        staticinvoke <org.spongycastle.crypto.tls.TlsUtils: void writeUint16(int,java.io.OutputStream)>($i0, r2);

        staticinvoke <org.spongycastle.crypto.tls.TlsUtils: void writeUint8(short,java.io.OutputStream)>($s1, r2);

        $r5 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsServer server>;

        $r12 = interfaceinvoke $r5.<org.spongycastle.crypto.tls.TlsServer: java.util.Hashtable getServerExtensions()>();

        $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: java.util.Hashtable serverExtensions> = $r12;

        $z1 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: boolean secure_renegotiation>;

        if $z1 == 0 goto label06;

        $r12 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: java.util.Hashtable serverExtensions>;

        $r13 = <org.spongycastle.crypto.tls.TlsProtocol: java.lang.Integer EXT_RenegotiationInfo>;

        $r9 = staticinvoke <org.spongycastle.crypto.tls.TlsUtils: byte[] getExtensionData(java.util.Hashtable,java.lang.Integer)>($r12, $r13);

        if $r9 != null goto label11;

        $z1 = 1;

     label05:
        if $z1 == 0 goto label06;

        $r12 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: java.util.Hashtable serverExtensions>;

        $r12 = staticinvoke <org.spongycastle.crypto.tls.TlsExtensionsUtils: java.util.Hashtable ensureExtensionsInitialised(java.util.Hashtable)>($r12);

        $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: java.util.Hashtable serverExtensions> = $r12;

        $r12 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: java.util.Hashtable serverExtensions>;

        $r13 = <org.spongycastle.crypto.tls.TlsProtocol: java.lang.Integer EXT_RenegotiationInfo>;

        $r9 = <org.spongycastle.crypto.tls.TlsUtils: byte[] EMPTY_BYTES>;

        $r9 = staticinvoke <org.spongycastle.crypto.tls.TlsProtocol: byte[] createRenegotiationInfo(byte[])>($r9);

        virtualinvoke $r12.<java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>($r13, $r9);

     label06:
        $z1 = $r4.<org.spongycastle.crypto.tls.SecurityParameters: boolean extendedMasterSecret>;

        if $z1 == 0 goto label07;

        $r12 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: java.util.Hashtable serverExtensions>;

        $r12 = staticinvoke <org.spongycastle.crypto.tls.TlsExtensionsUtils: java.util.Hashtable ensureExtensionsInitialised(java.util.Hashtable)>($r12);

        $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: java.util.Hashtable serverExtensions> = $r12;

        $r12 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: java.util.Hashtable serverExtensions>;

        staticinvoke <org.spongycastle.crypto.tls.TlsExtensionsUtils: void addExtendedMasterSecretExtension(java.util.Hashtable)>($r12);

     label07:
        $r12 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: java.util.Hashtable serverExtensions>;

        if $r12 == null goto label10;

        $r12 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: java.util.Hashtable serverExtensions>;

        $z1 = staticinvoke <org.spongycastle.crypto.tls.TlsExtensionsUtils: boolean hasEncryptThenMACExtension(java.util.Hashtable)>($r12);

        $r4.<org.spongycastle.crypto.tls.SecurityParameters: boolean encryptThenMAC> = $z1;

        $z1 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: boolean resumedSession>;

        $r12 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: java.util.Hashtable clientExtensions>;

        $r14 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: java.util.Hashtable serverExtensions>;

        $s1 = staticinvoke <org.spongycastle.crypto.tls.DTLSServerProtocol: short evaluateMaxFragmentLengthExtension(boolean,java.util.Hashtable,java.util.Hashtable,short)>($z1, $r12, $r14, 80);

        $r4.<org.spongycastle.crypto.tls.SecurityParameters: short maxFragmentLength> = $s1;

        $r12 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: java.util.Hashtable serverExtensions>;

        $z1 = staticinvoke <org.spongycastle.crypto.tls.TlsExtensionsUtils: boolean hasTruncatedHMacExtension(java.util.Hashtable)>($r12);

        $r4.<org.spongycastle.crypto.tls.SecurityParameters: boolean truncatedHMac> = $z1;

        $z1 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: boolean resumedSession>;

        if $z1 != 0 goto label12;

        $r12 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: java.util.Hashtable serverExtensions>;

        $r13 = <org.spongycastle.crypto.tls.TlsExtensionsUtils: java.lang.Integer EXT_status_request>;

        $z1 = staticinvoke <org.spongycastle.crypto.tls.TlsUtils: boolean hasExpectedEmptyExtensionData(java.util.Hashtable,java.lang.Integer,short)>($r12, $r13, 80);

        if $z1 == 0 goto label12;

        $z1 = 1;

     label08:
        $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: boolean allowCertificateStatus> = $z1;

        $z1 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: boolean resumedSession>;

        if $z1 != 0 goto label13;

        $r12 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: java.util.Hashtable serverExtensions>;

        $r13 = <org.spongycastle.crypto.tls.TlsProtocol: java.lang.Integer EXT_SessionTicket>;

        $z1 = staticinvoke <org.spongycastle.crypto.tls.TlsUtils: boolean hasExpectedEmptyExtensionData(java.util.Hashtable,java.lang.Integer,short)>($r12, $r13, 80);

        if $z1 == 0 goto label13;

     label09:
        $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: boolean expectSessionTicket> = $z0;

        $r12 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: java.util.Hashtable serverExtensions>;

        staticinvoke <org.spongycastle.crypto.tls.TlsProtocol: void writeExtensions(java.io.OutputStream,java.util.Hashtable)>(r2, $r12);

     label10:
        $r3 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsServerContextImpl serverContext>;

        $i0 = virtualinvoke $r4.<org.spongycastle.crypto.tls.SecurityParameters: int getCipherSuite()>();

        $i0 = staticinvoke <org.spongycastle.crypto.tls.TlsProtocol: int getPRFAlgorithm(org.spongycastle.crypto.tls.TlsContext,int)>($r3, $i0);

        $r4.<org.spongycastle.crypto.tls.SecurityParameters: int prfAlgorithm> = $i0;

        $r4.<org.spongycastle.crypto.tls.SecurityParameters: int verifyDataLength> = 12;

        $r9 = virtualinvoke r2.<java.io.ByteArrayOutputStream: byte[] toByteArray()>();

        return $r9;

     label11:
        $z1 = 0;

        goto label05;

     label12:
        $z1 = 0;

        goto label08;

     label13:
        $z0 = 0;

        goto label09;
    }
    public boolean getVerifyRequests()
    {
        org.spongycastle.crypto.tls.DTLSServerProtocol r0;
        boolean z0;

        r0 := @this: org.spongycastle.crypto.tls.DTLSServerProtocol;

        z0 = r0.<org.spongycastle.crypto.tls.DTLSServerProtocol: boolean verifyRequests>;

        return z0;
    }
    protected void notifyClientCertificate(org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState, org.spongycastle.crypto.tls.Certificate) throws java.io.IOException
    {
        org.spongycastle.crypto.tls.DTLSServerProtocol r0;
        org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState $r1;
        org.spongycastle.crypto.tls.Certificate $r2, $r5;
        org.spongycastle.crypto.tls.CertificateRequest $r3;
        java.lang.IllegalStateException $r4;
        org.spongycastle.crypto.tls.TlsFatalAlert $r6;
        boolean $z0;
        org.spongycastle.crypto.tls.TlsKeyExchange $r7;
        org.spongycastle.crypto.tls.TlsServer $r8;
        org.spongycastle.crypto.tls.TlsCredentials $r9;
        short $s0;

        r0 := @this: org.spongycastle.crypto.tls.DTLSServerProtocol;

        $r1 := @parameter0: org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState;

        $r2 := @parameter1: org.spongycastle.crypto.tls.Certificate;

        $r3 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.CertificateRequest certificateRequest>;

        if $r3 != null goto label1;

        $r4 = new java.lang.IllegalStateException;

        specialinvoke $r4.<java.lang.IllegalStateException: void <init>()>();

        throw $r4;

     label1:
        $r5 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.Certificate clientCertificate>;

        if $r5 == null goto label2;

        $r6 = new org.spongycastle.crypto.tls.TlsFatalAlert;

        specialinvoke $r6.<org.spongycastle.crypto.tls.TlsFatalAlert: void <init>(short)>(10);

        throw $r6;

     label2:
        $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.Certificate clientCertificate> = $r2;

        $z0 = virtualinvoke $r2.<org.spongycastle.crypto.tls.Certificate: boolean isEmpty()>();

        if $z0 == 0 goto label4;

        $r7 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsKeyExchange keyExchange>;

        interfaceinvoke $r7.<org.spongycastle.crypto.tls.TlsKeyExchange: void skipClientCredentials()>();

     label3:
        $r8 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsServer server>;

        interfaceinvoke $r8.<org.spongycastle.crypto.tls.TlsServer: void notifyClientCertificate(org.spongycastle.crypto.tls.Certificate)>($r2);

        return;

     label4:
        $r9 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsCredentials serverCredentials>;

        $r5 = interfaceinvoke $r9.<org.spongycastle.crypto.tls.TlsCredentials: org.spongycastle.crypto.tls.Certificate getCertificate()>();

        $s0 = staticinvoke <org.spongycastle.crypto.tls.TlsUtils: short getClientCertificateType(org.spongycastle.crypto.tls.Certificate,org.spongycastle.crypto.tls.Certificate)>($r2, $r5);

        $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: short clientCertificateType> = $s0;

        $r7 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsKeyExchange keyExchange>;

        interfaceinvoke $r7.<org.spongycastle.crypto.tls.TlsKeyExchange: void processClientCertificate(org.spongycastle.crypto.tls.Certificate)>($r2);

        goto label3;
    }
    protected void processCertificateVerify(org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState, byte[], org.spongycastle.crypto.tls.TlsHandshakeHash) throws java.io.IOException
    {
        org.spongycastle.crypto.tls.DTLSServerProtocol r0;
        org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState $r1;
        byte[] $r2, $r13;
        org.spongycastle.crypto.tls.TlsHandshakeHash $r3;
        java.io.ByteArrayInputStream r4;
        org.spongycastle.crypto.tls.TlsServerContextImpl r5;
        org.spongycastle.crypto.tls.DigitallySigned $r6;
        boolean z0, $z1;
        org.spongycastle.crypto.tls.SignatureAndHashAlgorithm $r7;
        short $s0;
        org.spongycastle.crypto.tls.Certificate $r8;
        org.spongycastle.asn1.x509.Certificate $r9;
        org.spongycastle.asn1.x509.SubjectPublicKeyInfo $r10;
        org.spongycastle.crypto.params.AsymmetricKeyParameter $r11;
        org.spongycastle.crypto.tls.TlsSigner $r12;
        org.spongycastle.crypto.tls.TlsFatalAlert $r14;
        org.spongycastle.crypto.tls.SecurityParameters $r15;
        java.lang.Exception $r16;

        r0 := @this: org.spongycastle.crypto.tls.DTLSServerProtocol;

        $r1 := @parameter0: org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState;

        $r2 := @parameter1: byte[];

        $r3 := @parameter2: org.spongycastle.crypto.tls.TlsHandshakeHash;

        r4 = new java.io.ByteArrayInputStream;

        specialinvoke r4.<java.io.ByteArrayInputStream: void <init>(byte[])>($r2);

        r5 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsServerContextImpl serverContext>;

        $r6 = staticinvoke <org.spongycastle.crypto.tls.DigitallySigned: org.spongycastle.crypto.tls.DigitallySigned parse(org.spongycastle.crypto.tls.TlsContext,java.io.InputStream)>(r5, r4);

        staticinvoke <org.spongycastle.crypto.tls.TlsProtocol: void assertEmpty(java.io.ByteArrayInputStream)>(r4);

        z0 = 0;

     label01:
        $z1 = staticinvoke <org.spongycastle.crypto.tls.TlsUtils: boolean isTLSv12(org.spongycastle.crypto.tls.TlsContext)>(r5);

     label02:
        if $z1 == 0 goto label07;

     label03:
        $r7 = virtualinvoke $r6.<org.spongycastle.crypto.tls.DigitallySigned: org.spongycastle.crypto.tls.SignatureAndHashAlgorithm getAlgorithm()>();

        $s0 = virtualinvoke $r7.<org.spongycastle.crypto.tls.SignatureAndHashAlgorithm: short getHash()>();

        $r2 = interfaceinvoke $r3.<org.spongycastle.crypto.tls.TlsHandshakeHash: byte[] getFinalHash(short)>($s0);

     label04:
        $r8 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.Certificate clientCertificate>;

        $r9 = virtualinvoke $r8.<org.spongycastle.crypto.tls.Certificate: org.spongycastle.asn1.x509.Certificate getCertificateAt(int)>(0);

        $r10 = virtualinvoke $r9.<org.spongycastle.asn1.x509.Certificate: org.spongycastle.asn1.x509.SubjectPublicKeyInfo getSubjectPublicKeyInfo()>();

        $r11 = staticinvoke <org.spongycastle.crypto.util.PublicKeyFactory: org.spongycastle.crypto.params.AsymmetricKeyParameter createKey(org.spongycastle.asn1.x509.SubjectPublicKeyInfo)>($r10);

        $s0 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: short clientCertificateType>;

        $r12 = staticinvoke <org.spongycastle.crypto.tls.TlsUtils: org.spongycastle.crypto.tls.TlsSigner createTlsSigner(short)>($s0);

        interfaceinvoke $r12.<org.spongycastle.crypto.tls.TlsSigner: void init(org.spongycastle.crypto.tls.TlsContext)>(r5);

        $r7 = virtualinvoke $r6.<org.spongycastle.crypto.tls.DigitallySigned: org.spongycastle.crypto.tls.SignatureAndHashAlgorithm getAlgorithm()>();

        $r13 = virtualinvoke $r6.<org.spongycastle.crypto.tls.DigitallySigned: byte[] getSignature()>();

        $z1 = interfaceinvoke $r12.<org.spongycastle.crypto.tls.TlsSigner: boolean verifyRawSignature(org.spongycastle.crypto.tls.SignatureAndHashAlgorithm,byte[],org.spongycastle.crypto.params.AsymmetricKeyParameter,byte[])>($r7, $r13, $r11, $r2);

     label05:
        z0 = $z1;

     label06:
        if z0 != 0 goto label09;

        $r14 = new org.spongycastle.crypto.tls.TlsFatalAlert;

        specialinvoke $r14.<org.spongycastle.crypto.tls.TlsFatalAlert: void <init>(short)>(51);

        throw $r14;

     label07:
        $r15 = virtualinvoke r5.<org.spongycastle.crypto.tls.TlsServerContextImpl: org.spongycastle.crypto.tls.SecurityParameters getSecurityParameters()>();

        $r2 = virtualinvoke $r15.<org.spongycastle.crypto.tls.SecurityParameters: byte[] getSessionHash()>();

     label08:
        goto label04;

     label09:
        return;

     label10:
        $r16 := @caughtexception;

        goto label06;

        catch java.lang.Exception from label01 to label02 with label10;
        catch java.lang.Exception from label03 to label04 with label10;
        catch java.lang.Exception from label04 to label05 with label10;
        catch java.lang.Exception from label07 to label08 with label10;
    }
    protected void processClientCertificate(org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState, byte[]) throws java.io.IOException
    {
        org.spongycastle.crypto.tls.DTLSServerProtocol r0;
        org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState $r1;
        byte[] $r2;
        java.io.ByteArrayInputStream r3;
        org.spongycastle.crypto.tls.Certificate $r4;

        r0 := @this: org.spongycastle.crypto.tls.DTLSServerProtocol;

        $r1 := @parameter0: org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState;

        $r2 := @parameter1: byte[];

        r3 = new java.io.ByteArrayInputStream;

        specialinvoke r3.<java.io.ByteArrayInputStream: void <init>(byte[])>($r2);

        $r4 = staticinvoke <org.spongycastle.crypto.tls.Certificate: org.spongycastle.crypto.tls.Certificate parse(java.io.InputStream)>(r3);

        staticinvoke <org.spongycastle.crypto.tls.TlsProtocol: void assertEmpty(java.io.ByteArrayInputStream)>(r3);

        virtualinvoke r0.<org.spongycastle.crypto.tls.DTLSServerProtocol: void notifyClientCertificate(org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState,org.spongycastle.crypto.tls.Certificate)>($r1, $r4);

        return;
    }
    protected void processClientHello(org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState, byte[]) throws java.io.IOException
    {
        org.spongycastle.crypto.tls.DTLSServerProtocol r0;
        org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState $r1;
        byte[] $r2, $r7;
        java.io.ByteArrayInputStream r3;
        org.spongycastle.crypto.tls.TlsServerContextImpl r4;
        org.spongycastle.crypto.tls.ProtocolVersion $r5;
        boolean $z0;
        org.spongycastle.crypto.tls.TlsFatalAlert $r6;
        int $i0, $i1;
        int[] $r8;
        short $s2;
        short[] $r9;
        java.util.Hashtable $r10;
        org.spongycastle.crypto.tls.SecurityParameters $r11;
        org.spongycastle.crypto.tls.TlsServer $r12;
        java.lang.Integer $r13;

        r0 := @this: org.spongycastle.crypto.tls.DTLSServerProtocol;

        $r1 := @parameter0: org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState;

        $r2 := @parameter1: byte[];

        r3 = new java.io.ByteArrayInputStream;

        specialinvoke r3.<java.io.ByteArrayInputStream: void <init>(byte[])>($r2);

        $r5 = staticinvoke <org.spongycastle.crypto.tls.TlsUtils: org.spongycastle.crypto.tls.ProtocolVersion readVersion(java.io.InputStream)>(r3);

        $z0 = virtualinvoke $r5.<org.spongycastle.crypto.tls.ProtocolVersion: boolean isDTLS()>();

        if $z0 != 0 goto label1;

        $r6 = new org.spongycastle.crypto.tls.TlsFatalAlert;

        specialinvoke $r6.<org.spongycastle.crypto.tls.TlsFatalAlert: void <init>(short)>(47);

        throw $r6;

     label1:
        $r2 = staticinvoke <org.spongycastle.crypto.tls.TlsUtils: byte[] readFully(int,java.io.InputStream)>(32, r3);

        $r7 = staticinvoke <org.spongycastle.crypto.tls.TlsUtils: byte[] readOpaque8(java.io.InputStream)>(r3);

        $i0 = lengthof $r7;

        if $i0 <= 32 goto label2;

        $r6 = new org.spongycastle.crypto.tls.TlsFatalAlert;

        specialinvoke $r6.<org.spongycastle.crypto.tls.TlsFatalAlert: void <init>(short)>(47);

        throw $r6;

     label2:
        staticinvoke <org.spongycastle.crypto.tls.TlsUtils: byte[] readOpaque8(java.io.InputStream)>(r3);

        $i0 = staticinvoke <org.spongycastle.crypto.tls.TlsUtils: int readUint16(java.io.InputStream)>(r3);

        if $i0 < 2 goto label3;

        $i1 = $i0 & 1;

        if $i1 == 0 goto label4;

     label3:
        $r6 = new org.spongycastle.crypto.tls.TlsFatalAlert;

        specialinvoke $r6.<org.spongycastle.crypto.tls.TlsFatalAlert: void <init>(short)>(50);

        throw $r6;

     label4:
        $i0 = $i0 / 2;

        $r8 = staticinvoke <org.spongycastle.crypto.tls.TlsUtils: int[] readUint16Array(int,java.io.InputStream)>($i0, r3);

        $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: int[] offeredCipherSuites> = $r8;

        $s2 = staticinvoke <org.spongycastle.crypto.tls.TlsUtils: short readUint8(java.io.InputStream)>(r3);

        if $s2 >= 1 goto label5;

        $r6 = new org.spongycastle.crypto.tls.TlsFatalAlert;

        specialinvoke $r6.<org.spongycastle.crypto.tls.TlsFatalAlert: void <init>(short)>(47);

        throw $r6;

     label5:
        $r9 = staticinvoke <org.spongycastle.crypto.tls.TlsUtils: short[] readUint8Array(int,java.io.InputStream)>($s2, r3);

        $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: short[] offeredCompressionMethods> = $r9;

        $r10 = staticinvoke <org.spongycastle.crypto.tls.TlsProtocol: java.util.Hashtable readExtensions(java.io.ByteArrayInputStream)>(r3);

        $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: java.util.Hashtable clientExtensions> = $r10;

        r4 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsServerContextImpl serverContext>;

        $r11 = virtualinvoke r4.<org.spongycastle.crypto.tls.TlsServerContextImpl: org.spongycastle.crypto.tls.SecurityParameters getSecurityParameters()>();

        $r10 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: java.util.Hashtable clientExtensions>;

        $z0 = staticinvoke <org.spongycastle.crypto.tls.TlsExtensionsUtils: boolean hasExtendedMasterSecretExtension(java.util.Hashtable)>($r10);

        $r11.<org.spongycastle.crypto.tls.SecurityParameters: boolean extendedMasterSecret> = $z0;

        virtualinvoke r4.<org.spongycastle.crypto.tls.TlsServerContextImpl: void setClientVersion(org.spongycastle.crypto.tls.ProtocolVersion)>($r5);

        $r12 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsServer server>;

        interfaceinvoke $r12.<org.spongycastle.crypto.tls.TlsServer: void notifyClientVersion(org.spongycastle.crypto.tls.ProtocolVersion)>($r5);

        $r12 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsServer server>;

        $r8 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: int[] offeredCipherSuites>;

        $z0 = staticinvoke <org.spongycastle.util.Arrays: boolean contains(int[],int)>($r8, 22016);

        interfaceinvoke $r12.<org.spongycastle.crypto.tls.TlsServer: void notifyFallback(boolean)>($z0);

        $r11.<org.spongycastle.crypto.tls.SecurityParameters: byte[] clientRandom> = $r2;

        $r12 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsServer server>;

        $r8 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: int[] offeredCipherSuites>;

        interfaceinvoke $r12.<org.spongycastle.crypto.tls.TlsServer: void notifyOfferedCipherSuites(int[])>($r8);

        $r12 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsServer server>;

        $r9 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: short[] offeredCompressionMethods>;

        interfaceinvoke $r12.<org.spongycastle.crypto.tls.TlsServer: void notifyOfferedCompressionMethods(short[])>($r9);

        $r8 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: int[] offeredCipherSuites>;

        $z0 = staticinvoke <org.spongycastle.util.Arrays: boolean contains(int[],int)>($r8, 255);

        if $z0 == 0 goto label6;

        $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: boolean secure_renegotiation> = 1;

     label6:
        $r10 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: java.util.Hashtable clientExtensions>;

        $r13 = <org.spongycastle.crypto.tls.TlsProtocol: java.lang.Integer EXT_RenegotiationInfo>;

        $r2 = staticinvoke <org.spongycastle.crypto.tls.TlsUtils: byte[] getExtensionData(java.util.Hashtable,java.lang.Integer)>($r10, $r13);

        if $r2 == null goto label7;

        $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: boolean secure_renegotiation> = 1;

        $r7 = <org.spongycastle.crypto.tls.TlsUtils: byte[] EMPTY_BYTES>;

        $r7 = staticinvoke <org.spongycastle.crypto.tls.TlsProtocol: byte[] createRenegotiationInfo(byte[])>($r7);

        $z0 = staticinvoke <org.spongycastle.util.Arrays: boolean constantTimeAreEqual(byte[],byte[])>($r2, $r7);

        if $z0 != 0 goto label7;

        $r6 = new org.spongycastle.crypto.tls.TlsFatalAlert;

        specialinvoke $r6.<org.spongycastle.crypto.tls.TlsFatalAlert: void <init>(short)>(40);

        throw $r6;

     label7:
        $r12 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsServer server>;

        $z0 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: boolean secure_renegotiation>;

        interfaceinvoke $r12.<org.spongycastle.crypto.tls.TlsServer: void notifySecureRenegotiation(boolean)>($z0);

        $r10 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: java.util.Hashtable clientExtensions>;

        if $r10 == null goto label8;

        $r12 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsServer server>;

        $r10 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: java.util.Hashtable clientExtensions>;

        interfaceinvoke $r12.<org.spongycastle.crypto.tls.TlsServer: void processClientExtensions(java.util.Hashtable)>($r10);

     label8:
        return;
    }
    protected void processClientKeyExchange(org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState, byte[]) throws java.io.IOException
    {
        org.spongycastle.crypto.tls.DTLSServerProtocol r0;
        org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState $r1;
        byte[] $r2;
        java.io.ByteArrayInputStream r3;
        org.spongycastle.crypto.tls.TlsKeyExchange $r4;

        r0 := @this: org.spongycastle.crypto.tls.DTLSServerProtocol;

        $r1 := @parameter0: org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState;

        $r2 := @parameter1: byte[];

        r3 = new java.io.ByteArrayInputStream;

        specialinvoke r3.<java.io.ByteArrayInputStream: void <init>(byte[])>($r2);

        $r4 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsKeyExchange keyExchange>;

        interfaceinvoke $r4.<org.spongycastle.crypto.tls.TlsKeyExchange: void processClientKeyExchange(java.io.InputStream)>(r3);

        staticinvoke <org.spongycastle.crypto.tls.TlsProtocol: void assertEmpty(java.io.ByteArrayInputStream)>(r3);

        return;
    }
    protected void processClientSupplementalData(org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState, byte[]) throws java.io.IOException
    {
        org.spongycastle.crypto.tls.DTLSServerProtocol r0;
        org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState $r1;
        byte[] $r2;
        java.io.ByteArrayInputStream r3;
        org.spongycastle.crypto.tls.TlsServer $r4;
        java.util.Vector $r5;

        r0 := @this: org.spongycastle.crypto.tls.DTLSServerProtocol;

        $r1 := @parameter0: org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState;

        $r2 := @parameter1: byte[];

        r3 = new java.io.ByteArrayInputStream;

        specialinvoke r3.<java.io.ByteArrayInputStream: void <init>(byte[])>($r2);

        $r5 = staticinvoke <org.spongycastle.crypto.tls.TlsProtocol: java.util.Vector readSupplementalDataMessage(java.io.ByteArrayInputStream)>(r3);

        $r4 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsServer server>;

        interfaceinvoke $r4.<org.spongycastle.crypto.tls.TlsServer: void processClientSupplementalData(java.util.Vector)>($r5);

        return;
    }
    protected org.spongycastle.crypto.tls.DTLSTransport serverHandshake(org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState, org.spongycastle.crypto.tls.DTLSRecordLayer) throws java.io.IOException
    {
        org.spongycastle.crypto.tls.DTLSServerProtocol r0;
        org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState $r1;
        org.spongycastle.crypto.tls.DTLSRecordLayer $r2;
        org.spongycastle.crypto.tls.DTLSReliableHandshake r3;
        org.spongycastle.crypto.tls.TlsServerContextImpl $r4, $r19;
        org.spongycastle.crypto.tls.SecurityParameters $r5;
        org.spongycastle.crypto.tls.DTLSReliableHandshake$Message $r6, r17;
        org.spongycastle.crypto.tls.ProtocolVersion $r7;
        short $s0;
        byte[] $r8, $r20;
        org.spongycastle.crypto.tls.TlsServer $r9;
        java.util.Vector $r10;
        org.spongycastle.crypto.tls.TlsKeyExchange $r11;
        org.spongycastle.crypto.tls.TlsCredentials $r12;
        org.spongycastle.crypto.tls.Certificate r13, $r24;
        boolean $z0;
        org.spongycastle.crypto.tls.CertificateStatus $r14;
        org.spongycastle.crypto.tls.CertificateRequest $r15;
        org.spongycastle.crypto.tls.TlsHandshakeHash $r16;
        org.spongycastle.crypto.tls.TlsCipher $r18;
        org.spongycastle.crypto.tls.NewSessionTicket $r21;
        org.spongycastle.crypto.tls.DTLSTransport $r22;
        org.spongycastle.crypto.tls.TlsFatalAlert $r23;

        r0 := @this: org.spongycastle.crypto.tls.DTLSServerProtocol;

        $r1 := @parameter0: org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState;

        $r2 := @parameter1: org.spongycastle.crypto.tls.DTLSRecordLayer;

        $r4 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsServerContextImpl serverContext>;

        $r5 = virtualinvoke $r4.<org.spongycastle.crypto.tls.TlsServerContextImpl: org.spongycastle.crypto.tls.SecurityParameters getSecurityParameters()>();

        r3 = new org.spongycastle.crypto.tls.DTLSReliableHandshake;

        $r4 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsServerContextImpl serverContext>;

        specialinvoke r3.<org.spongycastle.crypto.tls.DTLSReliableHandshake: void <init>(org.spongycastle.crypto.tls.TlsContext,org.spongycastle.crypto.tls.DTLSRecordLayer)>($r4, $r2);

        $r6 = virtualinvoke r3.<org.spongycastle.crypto.tls.DTLSReliableHandshake: org.spongycastle.crypto.tls.DTLSReliableHandshake$Message receiveMessage()>();

        $r7 = virtualinvoke $r2.<org.spongycastle.crypto.tls.DTLSRecordLayer: org.spongycastle.crypto.tls.ProtocolVersion getDiscoveredPeerVersion()>();

        $r4 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsServerContextImpl serverContext>;

        virtualinvoke $r4.<org.spongycastle.crypto.tls.TlsServerContextImpl: void setClientVersion(org.spongycastle.crypto.tls.ProtocolVersion)>($r7);

        $s0 = virtualinvoke $r6.<org.spongycastle.crypto.tls.DTLSReliableHandshake$Message: short getType()>();

        if $s0 != 1 goto label12;

        $r8 = virtualinvoke $r6.<org.spongycastle.crypto.tls.DTLSReliableHandshake$Message: byte[] getBody()>();

        virtualinvoke r0.<org.spongycastle.crypto.tls.DTLSServerProtocol: void processClientHello(org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState,byte[])>($r1, $r8);

        $r8 = virtualinvoke r0.<org.spongycastle.crypto.tls.DTLSServerProtocol: byte[] generateServerHello(org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState)>($r1);

        $s0 = $r5.<org.spongycastle.crypto.tls.SecurityParameters: short maxFragmentLength>;

        staticinvoke <org.spongycastle.crypto.tls.DTLSServerProtocol: void applyMaxFragmentLengthExtension(org.spongycastle.crypto.tls.DTLSRecordLayer,short)>($r2, $s0);

        virtualinvoke r3.<org.spongycastle.crypto.tls.DTLSReliableHandshake: void sendMessage(short,byte[])>(2, $r8);

        virtualinvoke r3.<org.spongycastle.crypto.tls.DTLSReliableHandshake: void notifyHelloComplete()>();

        $r9 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsServer server>;

        $r10 = interfaceinvoke $r9.<org.spongycastle.crypto.tls.TlsServer: java.util.Vector getServerSupplementalData()>();

        if $r10 == null goto label01;

        $r8 = staticinvoke <org.spongycastle.crypto.tls.DTLSServerProtocol: byte[] generateSupplementalData(java.util.Vector)>($r10);

        virtualinvoke r3.<org.spongycastle.crypto.tls.DTLSReliableHandshake: void sendMessage(short,byte[])>(23, $r8);

     label01:
        $r9 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsServer server>;

        $r11 = interfaceinvoke $r9.<org.spongycastle.crypto.tls.TlsServer: org.spongycastle.crypto.tls.TlsKeyExchange getKeyExchange()>();

        $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsKeyExchange keyExchange> = $r11;

        $r11 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsKeyExchange keyExchange>;

        $r4 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsServerContextImpl serverContext>;

        interfaceinvoke $r11.<org.spongycastle.crypto.tls.TlsKeyExchange: void init(org.spongycastle.crypto.tls.TlsContext)>($r4);

        $r9 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsServer server>;

        $r12 = interfaceinvoke $r9.<org.spongycastle.crypto.tls.TlsServer: org.spongycastle.crypto.tls.TlsCredentials getCredentials()>();

        $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsCredentials serverCredentials> = $r12;

        r13 = null;

        $r12 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsCredentials serverCredentials>;

        if $r12 != null goto label13;

        $r11 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsKeyExchange keyExchange>;

        interfaceinvoke $r11.<org.spongycastle.crypto.tls.TlsKeyExchange: void skipServerCredentials()>();

     label02:
        if r13 == null goto label03;

        $z0 = virtualinvoke r13.<org.spongycastle.crypto.tls.Certificate: boolean isEmpty()>();

        if $z0 == 0 goto label04;

     label03:
        $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: boolean allowCertificateStatus> = 0;

     label04:
        $z0 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: boolean allowCertificateStatus>;

        if $z0 == 0 goto label05;

        $r9 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsServer server>;

        $r14 = interfaceinvoke $r9.<org.spongycastle.crypto.tls.TlsServer: org.spongycastle.crypto.tls.CertificateStatus getCertificateStatus()>();

        if $r14 == null goto label05;

        $r8 = virtualinvoke r0.<org.spongycastle.crypto.tls.DTLSServerProtocol: byte[] generateCertificateStatus(org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState,org.spongycastle.crypto.tls.CertificateStatus)>($r1, $r14);

        virtualinvoke r3.<org.spongycastle.crypto.tls.DTLSReliableHandshake: void sendMessage(short,byte[])>(22, $r8);

     label05:
        $r11 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsKeyExchange keyExchange>;

        $r8 = interfaceinvoke $r11.<org.spongycastle.crypto.tls.TlsKeyExchange: byte[] generateServerKeyExchange()>();

        if $r8 == null goto label06;

        virtualinvoke r3.<org.spongycastle.crypto.tls.DTLSReliableHandshake: void sendMessage(short,byte[])>(12, $r8);

     label06:
        $r12 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsCredentials serverCredentials>;

        if $r12 == null goto label07;

        $r9 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsServer server>;

        $r15 = interfaceinvoke $r9.<org.spongycastle.crypto.tls.TlsServer: org.spongycastle.crypto.tls.CertificateRequest getCertificateRequest()>();

        $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.CertificateRequest certificateRequest> = $r15;

        $r15 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.CertificateRequest certificateRequest>;

        if $r15 == null goto label07;

        $r11 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsKeyExchange keyExchange>;

        $r15 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.CertificateRequest certificateRequest>;

        interfaceinvoke $r11.<org.spongycastle.crypto.tls.TlsKeyExchange: void validateCertificateRequest(org.spongycastle.crypto.tls.CertificateRequest)>($r15);

        $r15 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.CertificateRequest certificateRequest>;

        $r8 = virtualinvoke r0.<org.spongycastle.crypto.tls.DTLSServerProtocol: byte[] generateCertificateRequest(org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState,org.spongycastle.crypto.tls.CertificateRequest)>($r1, $r15);

        virtualinvoke r3.<org.spongycastle.crypto.tls.DTLSReliableHandshake: void sendMessage(short,byte[])>(13, $r8);

        $r16 = virtualinvoke r3.<org.spongycastle.crypto.tls.DTLSReliableHandshake: org.spongycastle.crypto.tls.TlsHandshakeHash getHandshakeHash()>();

        $r15 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.CertificateRequest certificateRequest>;

        $r10 = virtualinvoke $r15.<org.spongycastle.crypto.tls.CertificateRequest: java.util.Vector getSupportedSignatureAlgorithms()>();

        staticinvoke <org.spongycastle.crypto.tls.TlsUtils: void trackHashAlgorithms(org.spongycastle.crypto.tls.TlsHandshakeHash,java.util.Vector)>($r16, $r10);

     label07:
        $r8 = <org.spongycastle.crypto.tls.TlsUtils: byte[] EMPTY_BYTES>;

        virtualinvoke r3.<org.spongycastle.crypto.tls.DTLSReliableHandshake: void sendMessage(short,byte[])>(14, $r8);

        $r16 = virtualinvoke r3.<org.spongycastle.crypto.tls.DTLSReliableHandshake: org.spongycastle.crypto.tls.TlsHandshakeHash getHandshakeHash()>();

        interfaceinvoke $r16.<org.spongycastle.crypto.tls.TlsHandshakeHash: void sealHashAlgorithms()>();

        $r6 = virtualinvoke r3.<org.spongycastle.crypto.tls.DTLSReliableHandshake: org.spongycastle.crypto.tls.DTLSReliableHandshake$Message receiveMessage()>();

        r17 = $r6;

        $s0 = virtualinvoke $r6.<org.spongycastle.crypto.tls.DTLSReliableHandshake$Message: short getType()>();

        if $s0 != 23 goto label14;

        $r8 = virtualinvoke $r6.<org.spongycastle.crypto.tls.DTLSReliableHandshake$Message: byte[] getBody()>();

        virtualinvoke r0.<org.spongycastle.crypto.tls.DTLSServerProtocol: void processClientSupplementalData(org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState,byte[])>($r1, $r8);

        r17 = virtualinvoke r3.<org.spongycastle.crypto.tls.DTLSReliableHandshake: org.spongycastle.crypto.tls.DTLSReliableHandshake$Message receiveMessage()>();

     label08:
        $r15 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.CertificateRequest certificateRequest>;

        if $r15 != null goto label15;

        $r11 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsKeyExchange keyExchange>;

        interfaceinvoke $r11.<org.spongycastle.crypto.tls.TlsKeyExchange: void skipClientCredentials()>();

     label09:
        $s0 = virtualinvoke r17.<org.spongycastle.crypto.tls.DTLSReliableHandshake$Message: short getType()>();

        if $s0 != 16 goto label18;

        $r8 = virtualinvoke r17.<org.spongycastle.crypto.tls.DTLSReliableHandshake$Message: byte[] getBody()>();

        virtualinvoke r0.<org.spongycastle.crypto.tls.DTLSServerProtocol: void processClientKeyExchange(org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState,byte[])>($r1, $r8);

        $r16 = virtualinvoke r3.<org.spongycastle.crypto.tls.DTLSReliableHandshake: org.spongycastle.crypto.tls.TlsHandshakeHash prepareToFinish()>();

        $r4 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsServerContextImpl serverContext>;

        $r8 = staticinvoke <org.spongycastle.crypto.tls.TlsProtocol: byte[] getCurrentPRFHash(org.spongycastle.crypto.tls.TlsContext,org.spongycastle.crypto.tls.TlsHandshakeHash,byte[])>($r4, $r16, null);

        $r5.<org.spongycastle.crypto.tls.SecurityParameters: byte[] sessionHash> = $r8;

        $r4 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsServerContextImpl serverContext>;

        $r11 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsKeyExchange keyExchange>;

        staticinvoke <org.spongycastle.crypto.tls.TlsProtocol: void establishMasterSecret(org.spongycastle.crypto.tls.TlsContext,org.spongycastle.crypto.tls.TlsKeyExchange)>($r4, $r11);

        $r9 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsServer server>;

        $r18 = interfaceinvoke $r9.<org.spongycastle.crypto.tls.TlsServer: org.spongycastle.crypto.tls.TlsCipher getCipher()>();

        virtualinvoke $r2.<org.spongycastle.crypto.tls.DTLSRecordLayer: void initPendingEpoch(org.spongycastle.crypto.tls.TlsCipher)>($r18);

        $z0 = virtualinvoke r0.<org.spongycastle.crypto.tls.DTLSServerProtocol: boolean expectCertificateVerifyMessage(org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState)>($r1);

        if $z0 == 0 goto label10;

        $r8 = virtualinvoke r3.<org.spongycastle.crypto.tls.DTLSReliableHandshake: byte[] receiveMessageBody(short)>(15);

        virtualinvoke r0.<org.spongycastle.crypto.tls.DTLSServerProtocol: void processCertificateVerify(org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState,byte[],org.spongycastle.crypto.tls.TlsHandshakeHash)>($r1, $r8, $r16);

     label10:
        $r4 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsServerContextImpl serverContext>;

        $r19 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsServerContextImpl serverContext>;

        $r16 = virtualinvoke r3.<org.spongycastle.crypto.tls.DTLSReliableHandshake: org.spongycastle.crypto.tls.TlsHandshakeHash getHandshakeHash()>();

        $r8 = staticinvoke <org.spongycastle.crypto.tls.TlsProtocol: byte[] getCurrentPRFHash(org.spongycastle.crypto.tls.TlsContext,org.spongycastle.crypto.tls.TlsHandshakeHash,byte[])>($r19, $r16, null);

        $r8 = staticinvoke <org.spongycastle.crypto.tls.TlsUtils: byte[] calculateVerifyData(org.spongycastle.crypto.tls.TlsContext,java.lang.String,byte[])>($r4, "client finished", $r8);

        $r20 = virtualinvoke r3.<org.spongycastle.crypto.tls.DTLSReliableHandshake: byte[] receiveMessageBody(short)>(20);

        virtualinvoke r0.<org.spongycastle.crypto.tls.DTLSServerProtocol: void processFinished(byte[],byte[])>($r20, $r8);

        $z0 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: boolean expectSessionTicket>;

        if $z0 == 0 goto label11;

        $r9 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsServer server>;

        $r21 = interfaceinvoke $r9.<org.spongycastle.crypto.tls.TlsServer: org.spongycastle.crypto.tls.NewSessionTicket getNewSessionTicket()>();

        $r8 = virtualinvoke r0.<org.spongycastle.crypto.tls.DTLSServerProtocol: byte[] generateNewSessionTicket(org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState,org.spongycastle.crypto.tls.NewSessionTicket)>($r1, $r21);

        virtualinvoke r3.<org.spongycastle.crypto.tls.DTLSReliableHandshake: void sendMessage(short,byte[])>(4, $r8);

     label11:
        $r4 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsServerContextImpl serverContext>;

        $r19 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsServerContextImpl serverContext>;

        $r16 = virtualinvoke r3.<org.spongycastle.crypto.tls.DTLSReliableHandshake: org.spongycastle.crypto.tls.TlsHandshakeHash getHandshakeHash()>();

        $r8 = staticinvoke <org.spongycastle.crypto.tls.TlsProtocol: byte[] getCurrentPRFHash(org.spongycastle.crypto.tls.TlsContext,org.spongycastle.crypto.tls.TlsHandshakeHash,byte[])>($r19, $r16, null);

        $r8 = staticinvoke <org.spongycastle.crypto.tls.TlsUtils: byte[] calculateVerifyData(org.spongycastle.crypto.tls.TlsContext,java.lang.String,byte[])>($r4, "server finished", $r8);

        virtualinvoke r3.<org.spongycastle.crypto.tls.DTLSReliableHandshake: void sendMessage(short,byte[])>(20, $r8);

        virtualinvoke r3.<org.spongycastle.crypto.tls.DTLSReliableHandshake: void finish()>();

        $r9 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsServer server>;

        interfaceinvoke $r9.<org.spongycastle.crypto.tls.TlsServer: void notifyHandshakeComplete()>();

        $r22 = new org.spongycastle.crypto.tls.DTLSTransport;

        specialinvoke $r22.<org.spongycastle.crypto.tls.DTLSTransport: void <init>(org.spongycastle.crypto.tls.DTLSRecordLayer)>($r2);

        return $r22;

     label12:
        $r23 = new org.spongycastle.crypto.tls.TlsFatalAlert;

        specialinvoke $r23.<org.spongycastle.crypto.tls.TlsFatalAlert: void <init>(short)>(10);

        throw $r23;

     label13:
        $r11 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsKeyExchange keyExchange>;

        $r12 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsCredentials serverCredentials>;

        interfaceinvoke $r11.<org.spongycastle.crypto.tls.TlsKeyExchange: void processServerCredentials(org.spongycastle.crypto.tls.TlsCredentials)>($r12);

        $r12 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsCredentials serverCredentials>;

        $r24 = interfaceinvoke $r12.<org.spongycastle.crypto.tls.TlsCredentials: org.spongycastle.crypto.tls.Certificate getCertificate()>();

        r13 = $r24;

        $r8 = staticinvoke <org.spongycastle.crypto.tls.DTLSServerProtocol: byte[] generateCertificate(org.spongycastle.crypto.tls.Certificate)>($r24);

        virtualinvoke r3.<org.spongycastle.crypto.tls.DTLSReliableHandshake: void sendMessage(short,byte[])>(11, $r8);

        goto label02;

     label14:
        $r9 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsServer server>;

        interfaceinvoke $r9.<org.spongycastle.crypto.tls.TlsServer: void processClientSupplementalData(java.util.Vector)>(null);

        goto label08;

     label15:
        $s0 = virtualinvoke r17.<org.spongycastle.crypto.tls.DTLSReliableHandshake$Message: short getType()>();

        if $s0 != 11 goto label16;

        $r8 = virtualinvoke r17.<org.spongycastle.crypto.tls.DTLSReliableHandshake$Message: byte[] getBody()>();

        virtualinvoke r0.<org.spongycastle.crypto.tls.DTLSServerProtocol: void processClientCertificate(org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState,byte[])>($r1, $r8);

        r17 = virtualinvoke r3.<org.spongycastle.crypto.tls.DTLSReliableHandshake: org.spongycastle.crypto.tls.DTLSReliableHandshake$Message receiveMessage()>();

        goto label09;

     label16:
        $r4 = $r1.<org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState: org.spongycastle.crypto.tls.TlsServerContextImpl serverContext>;

        $z0 = staticinvoke <org.spongycastle.crypto.tls.TlsUtils: boolean isTLSv12(org.spongycastle.crypto.tls.TlsContext)>($r4);

        if $z0 == 0 goto label17;

        $r23 = new org.spongycastle.crypto.tls.TlsFatalAlert;

        specialinvoke $r23.<org.spongycastle.crypto.tls.TlsFatalAlert: void <init>(short)>(10);

        throw $r23;

     label17:
        r13 = <org.spongycastle.crypto.tls.Certificate: org.spongycastle.crypto.tls.Certificate EMPTY_CHAIN>;

        virtualinvoke r0.<org.spongycastle.crypto.tls.DTLSServerProtocol: void notifyClientCertificate(org.spongycastle.crypto.tls.DTLSServerProtocol$ServerHandshakeState,org.spongycastle.crypto.tls.Certificate)>($r1, r13);

        goto label09;

     label18:
        $r23 = new org.spongycastle.crypto.tls.TlsFatalAlert;

        specialinvoke $r23.<org.spongycastle.crypto.tls.TlsFatalAlert: void <init>(short)>(10);

        throw $r23;
    }
    public void setVerifyRequests(boolean)
    {
        org.spongycastle.crypto.tls.DTLSServerProtocol r0;
        boolean $z0;

        r0 := @this: org.spongycastle.crypto.tls.DTLSServerProtocol;

        $z0 := @parameter0: boolean;

        r0.<org.spongycastle.crypto.tls.DTLSServerProtocol: boolean verifyRequests> = $z0;

        return;
    }
